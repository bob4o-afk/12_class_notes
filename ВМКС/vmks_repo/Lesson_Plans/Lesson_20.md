# --- Тема 20 ---

Дата на провеждане 11.3.2022

Теми: Управление и използване на Течно-Кристален Екран (LCD)

## План на часа
- Какъв вид е 16x2 дисплея
- Как се използва стандартната [LCD библиотека](https://www.arduino.cc/en/Reference/LiquidCrystal) на Arduino
- Как се формира символ на екрана (матрица с общи изводи и сегментни изводи)
- Разглеждане на вътрешната структура и начин на работа на драйвера [HD44780](https://gitlab.com/tues-embedded/vmks/-/blob/master/Datasheets/HD44780.pdf)
- [Как се създава символ](https://www.arduino.cc/en/Reference/LiquidCrystalCreateChar) с използване на [онлайн програма за създаване на символи](https://maxpromer.github.io/LCD-Character-Creator/)
- Как се подават данни през интерфейса от микроконтролера
- Видове памет
	1. Flash - не-енергозависима, четене и запис, реализира се с MOSFET-и с плаващ гейт, (дълъг, но) ограничен живот - използва се в SSD-тата и в телефоните
	2. ROM - енерго-независима, само за четене, реализира се с проводници, вечна
	3. RAM - енерго-зависима, четене и запис, реализира се с кондензатори, вечна
		* SRAM - много бърза памет, типично 6 транзистора (много), голяма консумация на ток, голям размер върху кристала
		* DRAM - бърза памет, 1 транзистор и 1 кондензатор, малка консумация, малкък размер върху кристала
		* SDRAM - синхронна DRAM
- Как се инициализира драйвера и дисплея (има го добре обяснено във видеоклипа от първия линк в "Допълнително")
	1. Избира се 4-битов режим
	2. Изчиства се екрана
	3. Курсора се връща в началото
	4. Разрешава се работата на екрана
	5. Изпращат се символите за показване ...
- Обобщение

Бележки:
- Трябва да има 40ms изчакване в началото на програмата за да се инициализира драйвера след подаване на захранването
- Използва се [разширителен чип](https://gitlab.com/tues-embedded/vmks/-/tree/master/Useful%20Pictures/LCD/HD44780_COB_and_left_ic_is_40_output_extension_driver.JPG) за да стане броя символи 16x2 с драйвера HD44780

-----

### Допълнително:

[Как работи екрана и пример без използване на библиотека и въобще без микроконтролер](https://www.youtube.com/watch?v=cXpeTxC3_A4) ← съветвам ви да го изгледате този  
[Пример за използване с микропроцесор 6502 на асемблер](https://www.youtube.com/watch?v=FY3zTUaykVo)  
[Допълнително обяснение как работи този екран](https://www.engineersgarage.com/making-custom-characters-on-16x2-lcd/)  

[Картинки за различните видове дисплей с типовете им](https://gitlab.com/tues-embedded/vmks/-/tree/master/Useful%20Pictures/LCD/Types)

[Проста примерна програма за управление на LCD с HD44780 без библиотека](https://gitlab.com/tues-embedded/vmks/-/tree/master/Examples/LCD_without_library_simple)  
[По-пълна примерна програма за управление на LCD с HD44780 без библиотека](https://gitlab.com/tues-embedded/vmks/-/tree/master/Examples/LCD_without_library)  
[Примерна документация на LCD 16x2 модул](https://gitlab.com/tues-embedded/vmks/-/tree/master/Datasheets/LCD_16x2_example_datasheet_ADM1602K-NSW-FBS-3.3v.pdf)  

Кодът на стандартната библиотека LiquidCrystal на Arduino може да намерите в директория `C:\Users\[username]\Documents\Arduino\libraries\LiquidCrystal\src` под Windows (за друга ОС потърсете в интернет къде са библиотеките).

-----

Кодиране на символ - пример с буквата `h`, като активните пиксели са `1`:

```
1 - bit
1111 - nibble
11110000 - byte / octet
```

Ако кодираме пикселите вертикално от горе-надолу и от ляво на дясно:
```C++
0b 1111 1110 = 0xFE
0b 0001 0000 = 0x10
0b 0010 0000 = 0x20
0b 0010 0000 = 0x20
0b 0001 1110 = 0x1E

// Вертикално кодирано 'h'
byte h[8] = {0xFE, 0x10, 0x20, 0x20, 0x1E}; // => h

// В CGROM/CGRAM-а ще се получи нещо такова, но с различни букви
uint8_t characterMap[5][5] = 
{
	0xFE, 0x10, 0x20, 0x20, 0x1E,  // h
	0xFE, 0x10, 0x20, 0x20, 0x1E,  // h
	0xFE, 0x10, 0x20, 0x20, 0x1E,  // h
	0xFE, 0x10, 0x20, 0x20, 0x1E,  // h
	0xFE, 0x10, 0x20, 0x20, 0x1E   // h
}
```

Ако кодираме пикселите хоризонтално от ляво на дясно и от горе-надолу:
```C++
0b 0001 0000 => 0x10
0b 0001 0000 => 0x10
0b 0001 0110 => 0x16
0b 0001 1001 => 0x19
0b 0001 0001 => 0x11
0b 0001 0001 => 0x11
0b 0001 0001 => 0x11
0b 0000 0000 => 0x00

// Хоризонтално кодирано 'h'
byte h[8] = {0x10,0x10,0x16,0x19,0x11,0x11,0x11,0x00};

// В CGROM/CGRAM-а ще се получи нещо такова, но с различни букви
byte map[x][8] = {
	{0x10,0x10,0x16,0x19,0x11,0x11,0x11,0x00}, //h
	{0x10,0x10,0x16,0x19,0x11,0x11,0x11,0x00}, //h
	{0x10,0x10,0x16,0x19,0x11,0x11,0x11,0x00}, //h
	{0x10,0x10,0x16,0x19,0x11,0x11,0x11,0x00}, //h
	{0x10,0x10,0x16,0x19,0x11,0x11,0x11,0x00}, //h
	{0x10,0x10,0x16,0x19,0x11,0x11,0x11,0x00}  //h
}
```
